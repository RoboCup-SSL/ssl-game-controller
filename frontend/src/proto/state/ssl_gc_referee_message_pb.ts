// @generated by protoc-gen-es v2.2.3 with parameter "target=ts,json_types=true"
// @generated from file state/ssl_gc_referee_message.proto (syntax proto2)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { GameEvent, GameEventJson } from "./ssl_gc_game_event_pb";
import { file_state_ssl_gc_game_event } from "./ssl_gc_game_event_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file state/ssl_gc_referee_message.proto.
 */
export const file_state_ssl_gc_referee_message: GenFile = /*@__PURE__*/
  fileDesc("CiJzdGF0ZS9zc2xfZ2NfcmVmZXJlZV9tZXNzYWdlLnByb3RvItUOCgdSZWZlcmVlEhkKEXNvdXJjZV9pZGVudGlmaWVyGBIgASgJEi0KCm1hdGNoX3R5cGUYEyABKA4yCi5NYXRjaFR5cGU6DVVOS05PV05fTUFUQ0gSGAoQcGFja2V0X3RpbWVzdGFtcBgBIAIoBBIdCgVzdGFnZRgCIAIoDjIOLlJlZmVyZWUuU3RhZ2USFwoPc3RhZ2VfdGltZV9sZWZ0GAMgASgSEiEKB2NvbW1hbmQYBCACKA4yEC5SZWZlcmVlLkNvbW1hbmQSFwoPY29tbWFuZF9jb3VudGVyGAUgAigNEhkKEWNvbW1hbmRfdGltZXN0YW1wGAYgAigEEiEKBnllbGxvdxgHIAIoCzIRLlJlZmVyZWUuVGVhbUluZm8SHwoEYmx1ZRgIIAIoCzIRLlJlZmVyZWUuVGVhbUluZm8SKwoTZGVzaWduYXRlZF9wb3NpdGlvbhgJIAEoCzIOLlJlZmVyZWUuUG9pbnQSIgoaYmx1ZV90ZWFtX29uX3Bvc2l0aXZlX2hhbGYYCiABKAgSJgoMbmV4dF9jb21tYW5kGAwgASgOMhAuUmVmZXJlZS5Db21tYW5kEh8KC2dhbWVfZXZlbnRzGBAgAygLMgouR2FtZUV2ZW50EjUKFGdhbWVfZXZlbnRfcHJvcG9zYWxzGBEgAygLMhcuR2FtZUV2ZW50UHJvcG9zYWxHcm91cBIlCh1jdXJyZW50X2FjdGlvbl90aW1lX3JlbWFpbmluZxgPIAEoAxIWCg5zdGF0dXNfbWVzc2FnZRgUIAEoCRrkAwoIVGVhbUluZm8SDAoEbmFtZRgBIAIoCRINCgVzY29yZRgCIAIoDRIRCglyZWRfY2FyZHMYAyACKA0SHQoReWVsbG93X2NhcmRfdGltZXMYBCADKA1CAhABEhQKDHllbGxvd19jYXJkcxgFIAIoDRIQCgh0aW1lb3V0cxgGIAIoDRIUCgx0aW1lb3V0X3RpbWUYByACKA0SEgoKZ29hbGtlZXBlchgIIAIoDRIUCgxmb3VsX2NvdW50ZXIYCSABKA0SHwoXYmFsbF9wbGFjZW1lbnRfZmFpbHVyZXMYCiABKA0SFgoOY2FuX3BsYWNlX2JhbGwYDCABKAgSGAoQbWF4X2FsbG93ZWRfYm90cxgNIAEoDRIfChdib3Rfc3Vic3RpdHV0aW9uX2ludGVudBgOIAEoCBInCh9iYWxsX3BsYWNlbWVudF9mYWlsdXJlc19yZWFjaGVkGA8gASgIEiAKGGJvdF9zdWJzdGl0dXRpb25fYWxsb3dlZBgQIAEoCBIeChZib3Rfc3Vic3RpdHV0aW9uc19sZWZ0GBEgASgNEiIKGmJvdF9zdWJzdGl0dXRpb25fdGltZV9sZWZ0GBIgASgNEh4KCmh1bGxfY29sb3IYEyABKA4yCi5IdWxsQ29sb3IaHQoFUG9pbnQSCQoBeBgBIAIoAhIJCgF5GAIgAigCItECCgVTdGFnZRIZChVOT1JNQUxfRklSU1RfSEFMRl9QUkUQABIVChFOT1JNQUxfRklSU1RfSEFMRhABEhQKEE5PUk1BTF9IQUxGX1RJTUUQAhIaChZOT1JNQUxfU0VDT05EX0hBTEZfUFJFEAMSFgoSTk9STUFMX1NFQ09ORF9IQUxGEAQSFAoQRVhUUkFfVElNRV9CUkVBSxAFEhgKFEVYVFJBX0ZJUlNUX0hBTEZfUFJFEAYSFAoQRVhUUkFfRklSU1RfSEFMRhAHEhMKD0VYVFJBX0hBTEZfVElNRRAIEhkKFUVYVFJBX1NFQ09ORF9IQUxGX1BSRRAJEhUKEUVYVFJBX1NFQ09ORF9IQUxGEAoSGgoWUEVOQUxUWV9TSE9PVE9VVF9CUkVBSxALEhQKEFBFTkFMVFlfU0hPT1RPVVQQDBINCglQT1NUX0dBTUUQDSKWAwoHQ29tbWFuZBIICgRIQUxUEAASCAoEU1RPUBABEhAKDE5PUk1BTF9TVEFSVBACEg8KC0ZPUkNFX1NUQVJUEAMSGgoWUFJFUEFSRV9LSUNLT0ZGX1lFTExPVxAEEhgKFFBSRVBBUkVfS0lDS09GRl9CTFVFEAUSGgoWUFJFUEFSRV9QRU5BTFRZX1lFTExPVxAGEhgKFFBSRVBBUkVfUEVOQUxUWV9CTFVFEAcSFgoSRElSRUNUX0ZSRUVfWUVMTE9XEAgSFAoQRElSRUNUX0ZSRUVfQkxVRRAJEhwKFElORElSRUNUX0ZSRUVfWUVMTE9XEAoaAggBEhoKEklORElSRUNUX0ZSRUVfQkxVRRALGgIIARISCg5USU1FT1VUX1lFTExPVxAMEhAKDFRJTUVPVVRfQkxVRRANEhMKC0dPQUxfWUVMTE9XEA4aAggBEhEKCUdPQUxfQkxVRRAPGgIIARIZChVCQUxMX1BMQUNFTUVOVF9ZRUxMT1cQEBIXChNCQUxMX1BMQUNFTUVOVF9CTFVFEBFKBAgLEAxKBAgNEA5KBAgOEA8iVwoWR2FtZUV2ZW50UHJvcG9zYWxHcm91cBIKCgJpZBgDIAEoCRIfCgtnYW1lX2V2ZW50cxgBIAMoCzIKLkdhbWVFdmVudBIQCghhY2NlcHRlZBgCIAEoCCpUCglNYXRjaFR5cGUSEQoNVU5LTk9XTl9NQVRDSBAAEg8KC0dST1VQX1BIQVNFEAESFQoRRUxJTUlOQVRJT05fUEhBU0UQAhIMCghGUklFTkRMWRADKk4KCUh1bGxDb2xvchIWChJIVUxMX0NPTE9SX1VOS05PV04QABITCg9IVUxMX0NPTE9SX0RBUksQARIUChBIVUxMX0NPTE9SX0xJR0hUEAJCW0IYU3NsR2NSZWZlcmVlTWVzc2FnZVByb3RvUAFaPWdpdGh1Yi5jb20vUm9ib0N1cC1TU0wvc3NsLWdhbWUtY29udHJvbGxlci9pbnRlcm5hbC9hcHAvc3RhdGU", [file_state_ssl_gc_game_event]);

/**
 * Each UDP packet contains one of these messages.
 *
 * @generated from message Referee
 */
export type Referee = Message<"Referee"> & {
  /**
   * A random UUID of the source that is kept constant at the source while running
   * If multiple sources are broadcasting to the same network, this id can be used to identify individual sources
   *
   * @generated from field: optional string source_identifier = 18;
   */
  sourceIdentifier: string;

  /**
   * The match type is a meta information about the current match that helps to process the logs after a competition
   *
   * @generated from field: optional MatchType match_type = 19 [default = UNKNOWN_MATCH];
   */
  matchType: MatchType;

  /**
   * The UNIX timestamp when the packet was sent, in microseconds.
   * Divide by 1,000,000 to get a time_t.
   *
   * @generated from field: required uint64 packet_timestamp = 1;
   */
  packetTimestamp: bigint;

  /**
   * @generated from field: required Referee.Stage stage = 2;
   */
  stage: Referee_Stage;

  /**
   * The number of microseconds left in the stage.
   * The following stages have this value; the rest do not:
   * NORMAL_FIRST_HALF
   * NORMAL_HALF_TIME
   * NORMAL_SECOND_HALF
   * EXTRA_TIME_BREAK
   * EXTRA_FIRST_HALF
   * EXTRA_HALF_TIME
   * EXTRA_SECOND_HALF
   * PENALTY_SHOOTOUT_BREAK
   *
   * If the stage runs over its specified time, this value
   * becomes negative.
   *
   * @generated from field: optional sint64 stage_time_left = 3;
   */
  stageTimeLeft: bigint;

  /**
   * @generated from field: required Referee.Command command = 4;
   */
  command: Referee_Command;

  /**
   * The number of commands issued since startup (mod 2^32).
   *
   * @generated from field: required uint32 command_counter = 5;
   */
  commandCounter: number;

  /**
   * The UNIX timestamp when the command was issued, in microseconds.
   * This value changes only when a new command is issued, not on each packet.
   *
   * @generated from field: required uint64 command_timestamp = 6;
   */
  commandTimestamp: bigint;

  /**
   * Information about the two teams.
   *
   * @generated from field: required Referee.TeamInfo yellow = 7;
   */
  yellow?: Referee_TeamInfo;

  /**
   * @generated from field: required Referee.TeamInfo blue = 8;
   */
  blue?: Referee_TeamInfo;

  /**
   * @generated from field: optional Referee.Point designated_position = 9;
   */
  designatedPosition?: Referee_Point;

  /**
   * Information about the direction of play.
   * True, if the blue team will have it's goal on the positive x-axis of the ssl-vision coordinate system.
   * Obviously, the yellow team will play on the opposite half.
   *
   * @generated from field: optional bool blue_team_on_positive_half = 10;
   */
  blueTeamOnPositiveHalf: boolean;

  /**
   * The command that will be issued after the current stoppage and ball placement to continue the game.
   *
   * @generated from field: optional Referee.Command next_command = 12;
   */
  nextCommand: Referee_Command;

  /**
   * @generated from field: repeated GameEvent game_events = 16;
   */
  gameEvents: GameEvent[];

  /**
   * @generated from field: repeated GameEventProposalGroup game_event_proposals = 17;
   */
  gameEventProposals: GameEventProposalGroup[];

  /**
   * The time in microseconds that is remaining until the current action times out
   * The time will not be reset. It can get negative.
   * An autoRef would raise an appropriate event, if the time gets negative.
   * Possible actions where this time is relevant:
   *  * free kicks
   *  * kickoff, penalty kick, force start
   *  * ball placement
   *
   * @generated from field: optional int64 current_action_time_remaining = 15;
   */
  currentActionTimeRemaining: bigint;

  /**
   * A message that can be displayed to the spectators, like a reason for a stoppage.
   *
   * @generated from field: optional string status_message = 20;
   */
  statusMessage: string;
};

/**
 * Each UDP packet contains one of these messages.
 *
 * @generated from message Referee
 */
export type RefereeJson = {
  /**
   * A random UUID of the source that is kept constant at the source while running
   * If multiple sources are broadcasting to the same network, this id can be used to identify individual sources
   *
   * @generated from field: optional string source_identifier = 18;
   */
  sourceIdentifier?: string;

  /**
   * The match type is a meta information about the current match that helps to process the logs after a competition
   *
   * @generated from field: optional MatchType match_type = 19 [default = UNKNOWN_MATCH];
   */
  matchType?: MatchTypeJson;

  /**
   * The UNIX timestamp when the packet was sent, in microseconds.
   * Divide by 1,000,000 to get a time_t.
   *
   * @generated from field: required uint64 packet_timestamp = 1;
   */
  packetTimestamp?: string;

  /**
   * @generated from field: required Referee.Stage stage = 2;
   */
  stage?: Referee_StageJson;

  /**
   * The number of microseconds left in the stage.
   * The following stages have this value; the rest do not:
   * NORMAL_FIRST_HALF
   * NORMAL_HALF_TIME
   * NORMAL_SECOND_HALF
   * EXTRA_TIME_BREAK
   * EXTRA_FIRST_HALF
   * EXTRA_HALF_TIME
   * EXTRA_SECOND_HALF
   * PENALTY_SHOOTOUT_BREAK
   *
   * If the stage runs over its specified time, this value
   * becomes negative.
   *
   * @generated from field: optional sint64 stage_time_left = 3;
   */
  stageTimeLeft?: string;

  /**
   * @generated from field: required Referee.Command command = 4;
   */
  command?: Referee_CommandJson;

  /**
   * The number of commands issued since startup (mod 2^32).
   *
   * @generated from field: required uint32 command_counter = 5;
   */
  commandCounter?: number;

  /**
   * The UNIX timestamp when the command was issued, in microseconds.
   * This value changes only when a new command is issued, not on each packet.
   *
   * @generated from field: required uint64 command_timestamp = 6;
   */
  commandTimestamp?: string;

  /**
   * Information about the two teams.
   *
   * @generated from field: required Referee.TeamInfo yellow = 7;
   */
  yellow?: Referee_TeamInfoJson;

  /**
   * @generated from field: required Referee.TeamInfo blue = 8;
   */
  blue?: Referee_TeamInfoJson;

  /**
   * @generated from field: optional Referee.Point designated_position = 9;
   */
  designatedPosition?: Referee_PointJson;

  /**
   * Information about the direction of play.
   * True, if the blue team will have it's goal on the positive x-axis of the ssl-vision coordinate system.
   * Obviously, the yellow team will play on the opposite half.
   *
   * @generated from field: optional bool blue_team_on_positive_half = 10;
   */
  blueTeamOnPositiveHalf?: boolean;

  /**
   * The command that will be issued after the current stoppage and ball placement to continue the game.
   *
   * @generated from field: optional Referee.Command next_command = 12;
   */
  nextCommand?: Referee_CommandJson;

  /**
   * @generated from field: repeated GameEvent game_events = 16;
   */
  gameEvents?: GameEventJson[];

  /**
   * @generated from field: repeated GameEventProposalGroup game_event_proposals = 17;
   */
  gameEventProposals?: GameEventProposalGroupJson[];

  /**
   * The time in microseconds that is remaining until the current action times out
   * The time will not be reset. It can get negative.
   * An autoRef would raise an appropriate event, if the time gets negative.
   * Possible actions where this time is relevant:
   *  * free kicks
   *  * kickoff, penalty kick, force start
   *  * ball placement
   *
   * @generated from field: optional int64 current_action_time_remaining = 15;
   */
  currentActionTimeRemaining?: string;

  /**
   * A message that can be displayed to the spectators, like a reason for a stoppage.
   *
   * @generated from field: optional string status_message = 20;
   */
  statusMessage?: string;
};

/**
 * Describes the message Referee.
 * Use `create(RefereeSchema)` to create a new message.
 */
export const RefereeSchema: GenMessage<Referee, RefereeJson> = /*@__PURE__*/
  messageDesc(file_state_ssl_gc_referee_message, 0);

/**
 * Information about a single team.
 *
 * @generated from message Referee.TeamInfo
 */
export type Referee_TeamInfo = Message<"Referee.TeamInfo"> & {
  /**
   * The team's name (empty string if operator has not typed anything).
   *
   * @generated from field: required string name = 1;
   */
  name: string;

  /**
   * The number of goals scored by the team during normal play and overtime.
   *
   * @generated from field: required uint32 score = 2;
   */
  score: number;

  /**
   * The number of red cards issued to the team since the beginning of the game.
   *
   * @generated from field: required uint32 red_cards = 3;
   */
  redCards: number;

  /**
   * The amount of time (in microseconds) left on each yellow card issued to the team.
   * If no yellow cards are issued, this array has no elements.
   * Otherwise, times are ordered from smallest to largest.
   *
   * @generated from field: repeated uint32 yellow_card_times = 4 [packed = true];
   */
  yellowCardTimes: number[];

  /**
   * The total number of yellow cards ever issued to the team.
   *
   * @generated from field: required uint32 yellow_cards = 5;
   */
  yellowCards: number;

  /**
   * The number of timeouts this team can still call.
   * If in a timeout right now, that timeout is excluded.
   *
   * @generated from field: required uint32 timeouts = 6;
   */
  timeouts: number;

  /**
   * The number of microseconds of timeout this team can use.
   *
   * @generated from field: required uint32 timeout_time = 7;
   */
  timeoutTime: number;

  /**
   * The pattern number of this team's goalkeeper.
   *
   * @generated from field: required uint32 goalkeeper = 8;
   */
  goalkeeper: number;

  /**
   * The total number of countable fouls that act towards yellow cards
   *
   * @generated from field: optional uint32 foul_counter = 9;
   */
  foulCounter: number;

  /**
   * The number of consecutive ball placement failures of this team
   *
   * @generated from field: optional uint32 ball_placement_failures = 10;
   */
  ballPlacementFailures: number;

  /**
   * Indicate if the team is able and allowed to place the ball
   *
   * @generated from field: optional bool can_place_ball = 12;
   */
  canPlaceBall: boolean;

  /**
   * The maximum number of bots allowed on the field based on division and cards
   *
   * @generated from field: optional uint32 max_allowed_bots = 13;
   */
  maxAllowedBots: number;

  /**
   * The team has submitted an intent to substitute one or more robots at the next chance
   *
   * @generated from field: optional bool bot_substitution_intent = 14;
   */
  botSubstitutionIntent: boolean;

  /**
   * Indicate if the team reached the maximum allowed ball placement failures and is thus not allowed to place the ball anymore
   *
   * @generated from field: optional bool ball_placement_failures_reached = 15;
   */
  ballPlacementFailuresReached: boolean;

  /**
   * The team is allowed to substitute one or more robots currently
   *
   * @generated from field: optional bool bot_substitution_allowed = 16;
   */
  botSubstitutionAllowed: boolean;

  /**
   * The number of bot substitutions left by the team in this halftime
   *
   * @generated from field: optional uint32 bot_substitutions_left = 17;
   */
  botSubstitutionsLeft: number;

  /**
   * The number of microseconds left for current bot substitution
   *
   * @generated from field: optional uint32 bot_substitution_time_left = 18;
   */
  botSubstitutionTimeLeft: number;

  /**
   * The color of the hull of the robots of this team
   *
   * @generated from field: optional HullColor hull_color = 19;
   */
  hullColor: HullColor;
};

/**
 * Information about a single team.
 *
 * @generated from message Referee.TeamInfo
 */
export type Referee_TeamInfoJson = {
  /**
   * The team's name (empty string if operator has not typed anything).
   *
   * @generated from field: required string name = 1;
   */
  name?: string;

  /**
   * The number of goals scored by the team during normal play and overtime.
   *
   * @generated from field: required uint32 score = 2;
   */
  score?: number;

  /**
   * The number of red cards issued to the team since the beginning of the game.
   *
   * @generated from field: required uint32 red_cards = 3;
   */
  redCards?: number;

  /**
   * The amount of time (in microseconds) left on each yellow card issued to the team.
   * If no yellow cards are issued, this array has no elements.
   * Otherwise, times are ordered from smallest to largest.
   *
   * @generated from field: repeated uint32 yellow_card_times = 4 [packed = true];
   */
  yellowCardTimes?: number[];

  /**
   * The total number of yellow cards ever issued to the team.
   *
   * @generated from field: required uint32 yellow_cards = 5;
   */
  yellowCards?: number;

  /**
   * The number of timeouts this team can still call.
   * If in a timeout right now, that timeout is excluded.
   *
   * @generated from field: required uint32 timeouts = 6;
   */
  timeouts?: number;

  /**
   * The number of microseconds of timeout this team can use.
   *
   * @generated from field: required uint32 timeout_time = 7;
   */
  timeoutTime?: number;

  /**
   * The pattern number of this team's goalkeeper.
   *
   * @generated from field: required uint32 goalkeeper = 8;
   */
  goalkeeper?: number;

  /**
   * The total number of countable fouls that act towards yellow cards
   *
   * @generated from field: optional uint32 foul_counter = 9;
   */
  foulCounter?: number;

  /**
   * The number of consecutive ball placement failures of this team
   *
   * @generated from field: optional uint32 ball_placement_failures = 10;
   */
  ballPlacementFailures?: number;

  /**
   * Indicate if the team is able and allowed to place the ball
   *
   * @generated from field: optional bool can_place_ball = 12;
   */
  canPlaceBall?: boolean;

  /**
   * The maximum number of bots allowed on the field based on division and cards
   *
   * @generated from field: optional uint32 max_allowed_bots = 13;
   */
  maxAllowedBots?: number;

  /**
   * The team has submitted an intent to substitute one or more robots at the next chance
   *
   * @generated from field: optional bool bot_substitution_intent = 14;
   */
  botSubstitutionIntent?: boolean;

  /**
   * Indicate if the team reached the maximum allowed ball placement failures and is thus not allowed to place the ball anymore
   *
   * @generated from field: optional bool ball_placement_failures_reached = 15;
   */
  ballPlacementFailuresReached?: boolean;

  /**
   * The team is allowed to substitute one or more robots currently
   *
   * @generated from field: optional bool bot_substitution_allowed = 16;
   */
  botSubstitutionAllowed?: boolean;

  /**
   * The number of bot substitutions left by the team in this halftime
   *
   * @generated from field: optional uint32 bot_substitutions_left = 17;
   */
  botSubstitutionsLeft?: number;

  /**
   * The number of microseconds left for current bot substitution
   *
   * @generated from field: optional uint32 bot_substitution_time_left = 18;
   */
  botSubstitutionTimeLeft?: number;

  /**
   * The color of the hull of the robots of this team
   *
   * @generated from field: optional HullColor hull_color = 19;
   */
  hullColor?: HullColorJson;
};

/**
 * Describes the message Referee.TeamInfo.
 * Use `create(Referee_TeamInfoSchema)` to create a new message.
 */
export const Referee_TeamInfoSchema: GenMessage<Referee_TeamInfo, Referee_TeamInfoJson> = /*@__PURE__*/
  messageDesc(file_state_ssl_gc_referee_message, 0, 0);

/**
 * The coordinates of the Designated Position. These are measured in
 * millimetres and correspond to SSL-Vision coordinates. These fields are
 * always either both present (in the case of a ball placement command) or
 * both absent (in the case of any other command).
 *
 * @generated from message Referee.Point
 */
export type Referee_Point = Message<"Referee.Point"> & {
  /**
   * @generated from field: required float x = 1;
   */
  x: number;

  /**
   * @generated from field: required float y = 2;
   */
  y: number;
};

/**
 * The coordinates of the Designated Position. These are measured in
 * millimetres and correspond to SSL-Vision coordinates. These fields are
 * always either both present (in the case of a ball placement command) or
 * both absent (in the case of any other command).
 *
 * @generated from message Referee.Point
 */
export type Referee_PointJson = {
  /**
   * @generated from field: required float x = 1;
   */
  x?: number | "NaN" | "Infinity" | "-Infinity";

  /**
   * @generated from field: required float y = 2;
   */
  y?: number | "NaN" | "Infinity" | "-Infinity";
};

/**
 * Describes the message Referee.Point.
 * Use `create(Referee_PointSchema)` to create a new message.
 */
export const Referee_PointSchema: GenMessage<Referee_Point, Referee_PointJson> = /*@__PURE__*/
  messageDesc(file_state_ssl_gc_referee_message, 0, 1);

/**
 * These are the "coarse" stages of the game.
 *
 * @generated from enum Referee.Stage
 */
export enum Referee_Stage {
  /**
   * The first half is about to start.
   * A kickoff is called within this stage.
   * This stage ends with the NORMAL_START.
   *
   * @generated from enum value: NORMAL_FIRST_HALF_PRE = 0;
   */
  NORMAL_FIRST_HALF_PRE = 0,

  /**
   * The first half of the normal game, before half time.
   *
   * @generated from enum value: NORMAL_FIRST_HALF = 1;
   */
  NORMAL_FIRST_HALF = 1,

  /**
   * Half time between first and second halves.
   *
   * @generated from enum value: NORMAL_HALF_TIME = 2;
   */
  NORMAL_HALF_TIME = 2,

  /**
   * The second half is about to start.
   * A kickoff is called within this stage.
   * This stage ends with the NORMAL_START.
   *
   * @generated from enum value: NORMAL_SECOND_HALF_PRE = 3;
   */
  NORMAL_SECOND_HALF_PRE = 3,

  /**
   * The second half of the normal game, after half time.
   *
   * @generated from enum value: NORMAL_SECOND_HALF = 4;
   */
  NORMAL_SECOND_HALF = 4,

  /**
   * The break before extra time.
   *
   * @generated from enum value: EXTRA_TIME_BREAK = 5;
   */
  EXTRA_TIME_BREAK = 5,

  /**
   * The first half of extra time is about to start.
   * A kickoff is called within this stage.
   * This stage ends with the NORMAL_START.
   *
   * @generated from enum value: EXTRA_FIRST_HALF_PRE = 6;
   */
  EXTRA_FIRST_HALF_PRE = 6,

  /**
   * The first half of extra time.
   *
   * @generated from enum value: EXTRA_FIRST_HALF = 7;
   */
  EXTRA_FIRST_HALF = 7,

  /**
   * Half time between first and second extra halves.
   *
   * @generated from enum value: EXTRA_HALF_TIME = 8;
   */
  EXTRA_HALF_TIME = 8,

  /**
   * The second half of extra time is about to start.
   * A kickoff is called within this stage.
   * This stage ends with the NORMAL_START.
   *
   * @generated from enum value: EXTRA_SECOND_HALF_PRE = 9;
   */
  EXTRA_SECOND_HALF_PRE = 9,

  /**
   * The second half of extra time.
   *
   * @generated from enum value: EXTRA_SECOND_HALF = 10;
   */
  EXTRA_SECOND_HALF = 10,

  /**
   * The break before penalty shootout.
   *
   * @generated from enum value: PENALTY_SHOOTOUT_BREAK = 11;
   */
  PENALTY_SHOOTOUT_BREAK = 11,

  /**
   * The penalty shootout.
   *
   * @generated from enum value: PENALTY_SHOOTOUT = 12;
   */
  PENALTY_SHOOTOUT = 12,

  /**
   * The game is over.
   *
   * @generated from enum value: POST_GAME = 13;
   */
  POST_GAME = 13,
}

/**
 * These are the "coarse" stages of the game.
 *
 * @generated from enum Referee.Stage
 */
export type Referee_StageJson = "NORMAL_FIRST_HALF_PRE" | "NORMAL_FIRST_HALF" | "NORMAL_HALF_TIME" | "NORMAL_SECOND_HALF_PRE" | "NORMAL_SECOND_HALF" | "EXTRA_TIME_BREAK" | "EXTRA_FIRST_HALF_PRE" | "EXTRA_FIRST_HALF" | "EXTRA_HALF_TIME" | "EXTRA_SECOND_HALF_PRE" | "EXTRA_SECOND_HALF" | "PENALTY_SHOOTOUT_BREAK" | "PENALTY_SHOOTOUT" | "POST_GAME";

/**
 * Describes the enum Referee.Stage.
 */
export const Referee_StageSchema: GenEnum<Referee_Stage, Referee_StageJson> = /*@__PURE__*/
  enumDesc(file_state_ssl_gc_referee_message, 0, 0);

/**
 * These are the "fine" states of play on the field.
 *
 * @generated from enum Referee.Command
 */
export enum Referee_Command {
  /**
   * All robots should completely stop moving.
   *
   * @generated from enum value: HALT = 0;
   */
  HALT = 0,

  /**
   * Robots must keep 50 cm from the ball.
   *
   * @generated from enum value: STOP = 1;
   */
  STOP = 1,

  /**
   * A prepared kickoff or penalty may now be taken.
   *
   * @generated from enum value: NORMAL_START = 2;
   */
  NORMAL_START = 2,

  /**
   * The ball is dropped and free for either team.
   *
   * @generated from enum value: FORCE_START = 3;
   */
  FORCE_START = 3,

  /**
   * The yellow team may move into kickoff position.
   *
   * @generated from enum value: PREPARE_KICKOFF_YELLOW = 4;
   */
  PREPARE_KICKOFF_YELLOW = 4,

  /**
   * The blue team may move into kickoff position.
   *
   * @generated from enum value: PREPARE_KICKOFF_BLUE = 5;
   */
  PREPARE_KICKOFF_BLUE = 5,

  /**
   * The yellow team may move into penalty position.
   *
   * @generated from enum value: PREPARE_PENALTY_YELLOW = 6;
   */
  PREPARE_PENALTY_YELLOW = 6,

  /**
   * The blue team may move into penalty position.
   *
   * @generated from enum value: PREPARE_PENALTY_BLUE = 7;
   */
  PREPARE_PENALTY_BLUE = 7,

  /**
   * The yellow team may take a direct free kick.
   *
   * @generated from enum value: DIRECT_FREE_YELLOW = 8;
   */
  DIRECT_FREE_YELLOW = 8,

  /**
   * The blue team may take a direct free kick.
   *
   * @generated from enum value: DIRECT_FREE_BLUE = 9;
   */
  DIRECT_FREE_BLUE = 9,

  /**
   * The yellow team may take an indirect free kick.
   *
   * @generated from enum value: INDIRECT_FREE_YELLOW = 10 [deprecated = true];
   * @deprecated
   */
  INDIRECT_FREE_YELLOW = 10,

  /**
   * The blue team may take an indirect free kick.
   *
   * @generated from enum value: INDIRECT_FREE_BLUE = 11 [deprecated = true];
   * @deprecated
   */
  INDIRECT_FREE_BLUE = 11,

  /**
   * The yellow team is currently in a timeout.
   *
   * @generated from enum value: TIMEOUT_YELLOW = 12;
   */
  TIMEOUT_YELLOW = 12,

  /**
   * The blue team is currently in a timeout.
   *
   * @generated from enum value: TIMEOUT_BLUE = 13;
   */
  TIMEOUT_BLUE = 13,

  /**
   * The yellow team just scored a goal.
   * For information only.
   * Deprecated: Use the score field from the team infos instead. That way, you can also detect revoked goals.
   *
   * @generated from enum value: GOAL_YELLOW = 14 [deprecated = true];
   * @deprecated
   */
  GOAL_YELLOW = 14,

  /**
   * The blue team just scored a goal. See also GOAL_YELLOW.
   *
   * @generated from enum value: GOAL_BLUE = 15 [deprecated = true];
   * @deprecated
   */
  GOAL_BLUE = 15,

  /**
   * Equivalent to STOP, but the yellow team must pick up the ball and
   * drop it in the Designated Position.
   *
   * @generated from enum value: BALL_PLACEMENT_YELLOW = 16;
   */
  BALL_PLACEMENT_YELLOW = 16,

  /**
   * Equivalent to STOP, but the blue team must pick up the ball and drop
   * it in the Designated Position.
   *
   * @generated from enum value: BALL_PLACEMENT_BLUE = 17;
   */
  BALL_PLACEMENT_BLUE = 17,
}

/**
 * These are the "fine" states of play on the field.
 *
 * @generated from enum Referee.Command
 */
export type Referee_CommandJson = "HALT" | "STOP" | "NORMAL_START" | "FORCE_START" | "PREPARE_KICKOFF_YELLOW" | "PREPARE_KICKOFF_BLUE" | "PREPARE_PENALTY_YELLOW" | "PREPARE_PENALTY_BLUE" | "DIRECT_FREE_YELLOW" | "DIRECT_FREE_BLUE" | "INDIRECT_FREE_YELLOW" | "INDIRECT_FREE_BLUE" | "TIMEOUT_YELLOW" | "TIMEOUT_BLUE" | "GOAL_YELLOW" | "GOAL_BLUE" | "BALL_PLACEMENT_YELLOW" | "BALL_PLACEMENT_BLUE";

/**
 * Describes the enum Referee.Command.
 */
export const Referee_CommandSchema: GenEnum<Referee_Command, Referee_CommandJson> = /*@__PURE__*/
  enumDesc(file_state_ssl_gc_referee_message, 0, 1);

/**
 * List of matching proposals
 *
 * @generated from message GameEventProposalGroup
 */
export type GameEventProposalGroup = Message<"GameEventProposalGroup"> & {
  /**
   * Unique ID of this group
   *
   * @generated from field: optional string id = 3;
   */
  id: string;

  /**
   * The proposed game events
   *
   * @generated from field: repeated GameEvent game_events = 1;
   */
  gameEvents: GameEvent[];

  /**
   * Whether the proposal group was accepted
   *
   * @generated from field: optional bool accepted = 2;
   */
  accepted: boolean;
};

/**
 * List of matching proposals
 *
 * @generated from message GameEventProposalGroup
 */
export type GameEventProposalGroupJson = {
  /**
   * Unique ID of this group
   *
   * @generated from field: optional string id = 3;
   */
  id?: string;

  /**
   * The proposed game events
   *
   * @generated from field: repeated GameEvent game_events = 1;
   */
  gameEvents?: GameEventJson[];

  /**
   * Whether the proposal group was accepted
   *
   * @generated from field: optional bool accepted = 2;
   */
  accepted?: boolean;
};

/**
 * Describes the message GameEventProposalGroup.
 * Use `create(GameEventProposalGroupSchema)` to create a new message.
 */
export const GameEventProposalGroupSchema: GenMessage<GameEventProposalGroup, GameEventProposalGroupJson> = /*@__PURE__*/
  messageDesc(file_state_ssl_gc_referee_message, 1);

/**
 * MatchType is a meta information about the current match for easier log processing
 *
 * @generated from enum MatchType
 */
export enum MatchType {
  /**
   * not set
   *
   * @generated from enum value: UNKNOWN_MATCH = 0;
   */
  UNKNOWN_MATCH = 0,

  /**
   * match is part of the group phase
   *
   * @generated from enum value: GROUP_PHASE = 1;
   */
  GROUP_PHASE = 1,

  /**
   * match is part of the elimination phase
   *
   * @generated from enum value: ELIMINATION_PHASE = 2;
   */
  ELIMINATION_PHASE = 2,

  /**
   * a friendly match, not part of a tournament
   *
   * @generated from enum value: FRIENDLY = 3;
   */
  FRIENDLY = 3,
}

/**
 * MatchType is a meta information about the current match for easier log processing
 *
 * @generated from enum MatchType
 */
export type MatchTypeJson = "UNKNOWN_MATCH" | "GROUP_PHASE" | "ELIMINATION_PHASE" | "FRIENDLY";

/**
 * Describes the enum MatchType.
 */
export const MatchTypeSchema: GenEnum<MatchType, MatchTypeJson> = /*@__PURE__*/
  enumDesc(file_state_ssl_gc_referee_message, 0);

/**
 * HullColor is the color of the hull of the robots of a team
 *
 * @generated from enum HullColor
 */
export enum HullColor {
  /**
   * not set
   *
   * @generated from enum value: HULL_COLOR_UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * dark hull color
   *
   * @generated from enum value: HULL_COLOR_DARK = 1;
   */
  DARK = 1,

  /**
   * light hull color
   *
   * @generated from enum value: HULL_COLOR_LIGHT = 2;
   */
  LIGHT = 2,
}

/**
 * HullColor is the color of the hull of the robots of a team
 *
 * @generated from enum HullColor
 */
export type HullColorJson = "HULL_COLOR_UNKNOWN" | "HULL_COLOR_DARK" | "HULL_COLOR_LIGHT";

/**
 * Describes the enum HullColor.
 */
export const HullColorSchema: GenEnum<HullColor, HullColorJson> = /*@__PURE__*/
  enumDesc(file_state_ssl_gc_referee_message, 1);

