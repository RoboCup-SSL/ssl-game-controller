// @generated by protoc-gen-es v2.2.3 with parameter "target=ts,json_types=true"
// @generated from file rcon/ssl_gc_rcon_team.proto (syntax proto2)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Team, TeamJson } from "../state/ssl_gc_common_pb";
import { file_state_ssl_gc_common } from "../state/ssl_gc_common_pb";
import type { ControllerReply, ControllerReplyJson, Signature, SignatureJson } from "./ssl_gc_rcon_pb";
import { file_rcon_ssl_gc_rcon } from "./ssl_gc_rcon_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file rcon/ssl_gc_rcon_team.proto.
 */
export const file_rcon_ssl_gc_rcon_team: GenFile = /*@__PURE__*/
  fileDesc("ChtyY29uL3NzbF9nY19yY29uX3RlYW0ucHJvdG8iWQoQVGVhbVJlZ2lzdHJhdGlvbhIRCgl0ZWFtX25hbWUYASACKAkSHQoJc2lnbmF0dXJlGAIgASgLMgouU2lnbmF0dXJlEhMKBHRlYW0YAyABKA4yBS5UZWFtIqoBChBUZWFtVG9Db250cm9sbGVyEh0KCXNpZ25hdHVyZRgBIAEoCzIKLlNpZ25hdHVyZRIYCg5kZXNpcmVkX2tlZXBlchgCIAEoBUgAEiwKEGFkdmFudGFnZV9jaG9pY2UYAyABKA4yEC5BZHZhbnRhZ2VDaG9pY2VIABIYCg5zdWJzdGl0dXRlX2JvdBgEIAEoCEgAEg4KBHBpbmcYBSABKAhIAEIFCgNtc2ciTQoQQ29udHJvbGxlclRvVGVhbRIsChBjb250cm9sbGVyX3JlcGx5GAEgASgLMhAuQ29udHJvbGxlclJlcGx5SABCBQoDbXNnSgQIAhADKikKD0FkdmFudGFnZUNob2ljZRIICgRTVE9QEAASDAoIQ09OVElOVUUQAUJUQhJTc2xHY1Jjb25UZWFtUHJvdG9QAVo8Z2l0aHViLmNvbS9Sb2JvQ3VwLVNTTC9zc2wtZ2FtZS1jb250cm9sbGVyL2ludGVybmFsL2FwcC9yY29u", [file_state_ssl_gc_common, file_rcon_ssl_gc_rcon]);

/**
 * a registration that must be send by teams to the controller as the very first message
 *
 * @generated from message TeamRegistration
 */
export type TeamRegistration = Message<"TeamRegistration"> & {
  /**
   * the exact team name as published by the game-controller
   *
   * @generated from field: required string team_name = 1;
   */
  teamName: string;

  /**
   * signature can optionally be specified to enable secure communication
   *
   * @generated from field: optional Signature signature = 2;
   */
  signature?: Signature;

  /**
   * the team (relevant only if a team plays against itself)
   *
   * @generated from field: optional Team team = 3;
   */
  team: Team;
};

/**
 * a registration that must be send by teams to the controller as the very first message
 *
 * @generated from message TeamRegistration
 */
export type TeamRegistrationJson = {
  /**
   * the exact team name as published by the game-controller
   *
   * @generated from field: required string team_name = 1;
   */
  teamName?: string;

  /**
   * signature can optionally be specified to enable secure communication
   *
   * @generated from field: optional Signature signature = 2;
   */
  signature?: SignatureJson;

  /**
   * the team (relevant only if a team plays against itself)
   *
   * @generated from field: optional Team team = 3;
   */
  team?: TeamJson;
};

/**
 * Describes the message TeamRegistration.
 * Use `create(TeamRegistrationSchema)` to create a new message.
 */
export const TeamRegistrationSchema: GenMessage<TeamRegistration, TeamRegistrationJson> = /*@__PURE__*/
  messageDesc(file_rcon_ssl_gc_rcon_team, 0);

/**
 * wrapper for all messages from a team's computer to the controller
 *
 * @generated from message TeamToController
 */
export type TeamToController = Message<"TeamToController"> & {
  /**
   * signature can optionally be specified to enable secure communication
   *
   * @generated from field: optional Signature signature = 1;
   */
  signature?: Signature;

  /**
   * @generated from oneof TeamToController.msg
   */
  msg: {
    /**
     * request a new desired keeper id
     *
     * @generated from field: int32 desired_keeper = 2;
     */
    value: number;
    case: "desiredKeeper";
  } | {
    /**
     * response to an advantage choice request
     *
     * @generated from field: AdvantageChoice advantage_choice = 3;
     */
    value: AdvantageChoice;
    case: "advantageChoice";
  } | {
    /**
     * request to substitute a robot at the next possibility
     *
     * @generated from field: bool substitute_bot = 4;
     */
    value: boolean;
    case: "substituteBot";
  } | {
    /**
     * send a ping to the GC to test if the connection is still open.
     * the value is ignored and a reply is sent back
     *
     * @generated from field: bool ping = 5;
     */
    value: boolean;
    case: "ping";
  } | { case: undefined; value?: undefined };
};

/**
 * wrapper for all messages from a team's computer to the controller
 *
 * @generated from message TeamToController
 */
export type TeamToControllerJson = {
  /**
   * signature can optionally be specified to enable secure communication
   *
   * @generated from field: optional Signature signature = 1;
   */
  signature?: SignatureJson;

  /**
   * request a new desired keeper id
   *
   * @generated from field: int32 desired_keeper = 2;
   */
  desiredKeeper?: number;

  /**
   * response to an advantage choice request
   *
   * @generated from field: AdvantageChoice advantage_choice = 3;
   */
  advantageChoice?: AdvantageChoiceJson;

  /**
   * request to substitute a robot at the next possibility
   *
   * @generated from field: bool substitute_bot = 4;
   */
  substituteBot?: boolean;

  /**
   * send a ping to the GC to test if the connection is still open.
   * the value is ignored and a reply is sent back
   *
   * @generated from field: bool ping = 5;
   */
  ping?: boolean;
};

/**
 * Describes the message TeamToController.
 * Use `create(TeamToControllerSchema)` to create a new message.
 */
export const TeamToControllerSchema: GenMessage<TeamToController, TeamToControllerJson> = /*@__PURE__*/
  messageDesc(file_rcon_ssl_gc_rcon_team, 1);

/**
 * wrapper for all messages from controller to a team's computer
 *
 * @generated from message ControllerToTeam
 */
export type ControllerToTeam = Message<"ControllerToTeam"> & {
  /**
   * @generated from oneof ControllerToTeam.msg
   */
  msg: {
    /**
     * a reply from the controller
     *
     * @generated from field: ControllerReply controller_reply = 1;
     */
    value: ControllerReply;
    case: "controllerReply";
  } | { case: undefined; value?: undefined };
};

/**
 * wrapper for all messages from controller to a team's computer
 *
 * @generated from message ControllerToTeam
 */
export type ControllerToTeamJson = {
  /**
   * a reply from the controller
   *
   * @generated from field: ControllerReply controller_reply = 1;
   */
  controllerReply?: ControllerReplyJson;
};

/**
 * Describes the message ControllerToTeam.
 * Use `create(ControllerToTeamSchema)` to create a new message.
 */
export const ControllerToTeamSchema: GenMessage<ControllerToTeam, ControllerToTeamJson> = /*@__PURE__*/
  messageDesc(file_rcon_ssl_gc_rcon_team, 2);

/**
 * the current advantage choice of the team
 * the choice is valid until another choice is received
 * if the team disconnects, the choice is reset to its default (STOP)
 * teams may either send their current choice continuously or only on change
 *
 * @generated from enum AdvantageChoice
 */
export enum AdvantageChoice {
  /**
   * stop the game
   *
   * @generated from enum value: STOP = 0;
   */
  STOP = 0,

  /**
   * keep the game running
   *
   * @generated from enum value: CONTINUE = 1;
   */
  CONTINUE = 1,
}

/**
 * the current advantage choice of the team
 * the choice is valid until another choice is received
 * if the team disconnects, the choice is reset to its default (STOP)
 * teams may either send their current choice continuously or only on change
 *
 * @generated from enum AdvantageChoice
 */
export type AdvantageChoiceJson = "STOP" | "CONTINUE";

/**
 * Describes the enum AdvantageChoice.
 */
export const AdvantageChoiceSchema: GenEnum<AdvantageChoice, AdvantageChoiceJson> = /*@__PURE__*/
  enumDesc(file_rcon_ssl_gc_rcon_team, 0);

